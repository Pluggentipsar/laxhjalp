import { AzureOpenAI, OpenAI } from 'openai';
import { segmentText } from './ocrService.js';

// Lazy initialization
let openai = null;
let useAzure = false;

function getOpenAIClient() {
  if (openai) return openai;

  useAzure = !!process.env.AZURE_OPENAI_ENDPOINT;

  if (useAzure) {
    openai = new AzureOpenAI({
      apiKey: process.env.AZURE_OPENAI_KEY,
      endpoint: process.env.AZURE_OPENAI_ENDPOINT,
      apiVersion: process.env.AZURE_API_VERSION || '2024-12-01-preview',
    });
  } else {
    openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY
    });
  }

  return openai;
}

// H√§mta deployment/model names
const getChatModel = () => {
  return useAzure
    ? process.env.AZURE_DEPLOYMENT_NAME || 'gpt-5-mini'
    : 'gpt-4o-mini';
};

const getEmbeddingModel = () => {
  return useAzure
    ? process.env.AZURE_EMBEDDING_DEPLOYMENT || 'text-embedding-3-small'
    : 'text-embedding-3-small';
};

function getMaxTokenOptions(value) {
  return useAzure
    ? { max_completion_tokens: value }
    : { max_tokens: value };
}

function getTemperatureOptions(value) {
  if (useAzure) {
    return {};
  }
  return { temperature: value };
}

/**
 * Generera embeddings f√∂r text-chunks (f√∂r RAG)
 */
export async function generateEmbeddings(content, chunkSize = 500) {
  const client = getOpenAIClient();

  try {
    // Segmentera text i chunks
    const chunks = segmentText(content, chunkSize);

    // Generera embeddings f√∂r varje chunk
    const embeddingsPromises = chunks.map(async (chunk, index) => {
      const response = await client.embeddings.create({
        model: getEmbeddingModel(),
        input: chunk
      });

      return {
        id: crypto.randomUUID(),
        text: chunk,
        embedding: response.data[0].embedding,
        index
      };
    });

    const embeddings = await Promise.all(embeddingsPromises);
    return embeddings;
  } catch (error) {
    console.error('Embeddings-generering fel:', error);
    throw new Error(`Kunde inte generera embeddings: ${error.message}`);
  }
}

/**
 * Ber√§kna cosine similarity mellan tv√• vektorer
 */
function cosineSimilarity(vecA, vecB) {
  const dotProduct = vecA.reduce((sum, a, i) => sum + a * vecB[i], 0);
  const magnitudeA = Math.sqrt(vecA.reduce((sum, a) => sum + a * a, 0));
  const magnitudeB = Math.sqrt(vecB.reduce((sum, b) => sum + b * b, 0));
  return dotProduct / (magnitudeA * magnitudeB);
}

/**
 * Hitta mest relevanta chunks baserat p√• fr√•ga
 */
async function findRelevantChunks(question, chunks, topK = 3) {
  const client = getOpenAIClient();

  // Generera embedding f√∂r fr√•gan
  const questionEmbedding = await client.embeddings.create({
    model: getEmbeddingModel(),
    input: question
  });

  const questionVec = questionEmbedding.data[0].embedding;

  // Ber√§kna similarity f√∂r varje chunk
  const similarities = chunks.map(chunk => ({
    chunk,
    similarity: cosineSimilarity(questionVec, chunk.embedding)
  }));

  // Sortera och returnera top K
  return similarities
    .sort((a, b) => b.similarity - a.similarity)
    .slice(0, topK)
    .map(s => s.chunk);
}

/**
 * Generera system prompt baserat p√• chattl√§ge
 */
function getSystemPromptForMode(mode, grade, context) {
  const baseIntro = `Du √§r en v√§nlig och hj√§lpsam AI-assistent f√∂r en elev i √•rskurs ${grade}.`;

  const modePrompts = {
    free: `${baseIntro}

Din uppgift √§r att:
- Svara p√• elevens fr√•gor om studiematerialet
- F√∂rklara begrepp p√• ett enkelt s√§tt
- Ge konkreta exempel
- Vara t√•lmodig och uppmuntrande
- H√§nvisa till materialet n√§r det √§r relevant

Viktigt:
- Anv√§nd enkelt spr√•k anpassat f√∂r √•rskurs ${grade}
- Ge konstruktiv feedback
- Uppmuntra nyfikenhet

STUDIEMATERIAL:
${context}`,

    socratic: `${baseIntro}

Du anv√§nder den SOKRATISKA METODEN f√∂r att hj√§lpa eleven l√§ra sig.

Dina principer:
- St√§ll EN ledande fr√•ga i taget
- GE ALDRIG direkt svar - guide eleven till att t√§nka sj√§lv
- Ge ledtr√•dar och v√§gledning ist√§llet f√∂r facit
- Bekr√§fta korrekt t√§nkande men l√•t eleven komma fram till slutsatsen
- Om eleven fastnar, ge en mindre ledtr√•d eller omformulera fr√•gan
- Var uppmuntrande √§ven n√§r eleven svarar fel
- Fira n√§r eleven kommer p√• r√§tt svar sj√§lv!

Viktigt:
- Fokusera p√• EN koncept eller begrepp √•t g√•ngen
- Bygg p√• elevens f√∂rkunskaper
- Anv√§nd spr√•k anpassat f√∂r √•rskurs ${grade}

STUDIEMATERIAL:
${context}`,

    adventure: `${baseIntro}

Du skapar ett INTERAKTIVT TEXT√ÑVENTYR baserat p√• studiematerialet.

Din uppgift:
- Bygg en sp√§nnande ber√§ttelse d√§r eleven √§r huvudperson
- "Smuggla in" materialets koncept och fakta naturligt i ber√§ttelsen
- Presentera EXAKT 3 val efter varje stycke
- Valen ska ha olika sv√•righetsgrad och leda till olika l√§roupplevelser
- G√∂r det roligt, engagerande och √•ldersanpassat!
- Varva action med reflektion

VIKTIGT FORMAT - Anv√§nd ALLTID radbrytningar f√∂r l√§sbarhet:

[En kort, sp√§nnande ber√§ttelsedel (2-4 meningar)]

**Vad g√∂r du?**
A) [Val 1 - enklare]
B) [Val 2 - mellan]
C) [Val 3 - sv√•rare]

Exempel p√• bra formatering:
"Du st√•r vid ing√•ngen till det antika biblioteket i Alexandria. R√∂k stiger fr√•n byggnaden - brand!

**Vad g√∂r du?**
A) Spring in och r√§dda de n√§rmaste skriftrullarna
B) Organisera en kedja av m√§nniskor f√∂r att r√§dda s√• mycket som m√∂jligt
C) F√∂rs√∂k hitta vattenk√§llan f√∂r att sl√§cka elden vid k√§llan

V√§lj A, B eller C! üó∫Ô∏è"

Viktigt:
- Anv√§nd ALLTID radbrytningar mellan ber√§ttelse och val
- H√•ll varje del kort och engagerande (2-4 meningar)
- Anpassa spr√•k och inneh√•ll f√∂r √•rskurs ${grade}
- Koppla alltid tillbaka till studiematerialet

STUDIEMATERIAL:
${context}`,

    'active-learning': `${baseIntro}

Du kombinerar F√ñRKLARING med PRAKTISKA UPPGIFTER.

Din metod:
1. F√∂rklara ett koncept kort och tydligt
2. Ge ett konkret exempel
3. Be eleven APPLICERA konceptet p√• ett nytt scenario
4. Ge feedback p√• elevens f√∂rs√∂k
5. G√• vidare till n√§sta koncept

Viktigt:
- Balansera teori och praktik
- Ge omedelbar, konstruktiv feedback
- Anpassa sv√•righetsgrad efter elevens prestationer
- Anv√§nd varierade exempel fr√•n elevens vardag
- Spr√•k anpassat f√∂r √•rskurs ${grade}

STUDIEMATERIAL:
${context}`,

    quiz: `${baseIntro}

Du √§r QUIZ-M√ÑSTAREN som testar elevens kunskap p√• ett engagerande s√§tt.

Din uppgift:
- Generera fr√•gor fr√•n materialet (flerval, sant/falskt, √∂ppna fr√•gor)
- Ge ALLTID f√∂rklaring efter svaret (oavsett om r√§tt eller fel)
- Uppmuntra och motivera
- Anpassa sv√•righetsgrad baserat p√• elevens svar
- H√•ll koll p√• vad som t√§ckts

VIKTIGT FORMAT - Anv√§nd ALLTID radbrytningar f√∂r l√§sbarhet:

**Fr√•ga:**
[Din fr√•ga h√§r]

**Alternativ:**
A) [Alternativ 1]
B) [Alternativ 2]
C) [Alternativ 3]
D) [Alternativ 4]

Exempel p√• bra formatering:
"H√§r kommer n√§sta fr√•ga!

**Fr√•ga:**
Vilket alternativ beskriver b√§st vad "epik" √§r?

**Alternativ:**
A) Korta, intensiva dikter om k√§rlek
B) L√•nga √§ventyr som Homeros Odysse√©n
C) Pj√§ser som spelas inf√∂r publik
D) Kortare ber√§ttelser med djur som l√§r ut moral

V√§lj A, B, C eller D. Lycka till! üèÜ"

N√§r eleven svarar:
- Bekr√§fta om r√§tt eller fel
- F√∂rklara VARF√ñR (h√§nvisa till materialet)
- Ge positiv feedback
- St√§ll n√§sta fr√•ga med samma tydliga format

Viktigt:
- Anv√§nd ALLTID radbrytningar mellan fr√•ga och alternativ
- Variera fr√•getyper
- Spr√•k anpassat f√∂r √•rskurs ${grade}
- Fokusera p√• f√∂rst√•else, inte bara memorering

STUDIEMATERIAL:
${context}`,

    discussion: `${baseIntro}

Du √§r en DISKUSSIONSPARTNER som hj√§lper eleven utveckla kritiskt t√§nkande.

Din uppgift:
- Presentera olika perspektiv och tolkningar
- St√§ll "Vad h√§nder om...?" fr√•gor
- Argumentera f√∂r olika synvinklar
- Utmana elevens antaganden (p√• ett konstruktivt s√§tt)
- Uppmuntra eleven att t√§nka djupare

Metod:
- Lyssna p√• elevens √•sikter
- Presentera motargument eller alternativa perspektiv
- Fr√•ga efter elevens resonemang och bevis
- Hj√§lp eleven se kopplingar och konsekvenser
- Erk√§nn n√§r eleven g√∂r bra po√§nger!

Viktigt:
- Var respektfull √§ven n√§r du utmanar
- Anv√§nd spr√•k anpassat f√∂r √•rskurs ${grade}
- Fokusera p√• materialets inneh√•ll
- Uppmuntra √∂ppenhet och nyfikenhet

STUDIEMATERIAL:
${context}`
  };

  return modePrompts[mode] || modePrompts.free;
}

/**
 * RAG-baserad chat med studiematerial
 */
export async function chatWithMaterial(materialContent, previousMessages, userMessage, options = {}) {
  const { grade = 5, mode = 'free' } = options;
  const client = getOpenAIClient();

  console.log('[chatService] chatWithMaterial called', { mode, grade, userMessage: userMessage.substring(0, 50) });

  try{
    // 1. Generera embeddings f√∂r materialet (om inte redan gjort)
    // I praktiken skulle detta vara cachat i Dexie
    const chunks = await generateEmbeddings(materialContent);
    console.log('[chatService] Generated', chunks.length, 'chunks');

    // 2. Hitta relevanta chunks f√∂r anv√§ndarens fr√•ga
    const relevantChunks = await findRelevantChunks(userMessage, chunks, 3);
    const context = relevantChunks.map(c => c.text).join('\n\n');
    console.log('[chatService] Found', relevantChunks.length, 'relevant chunks');

    // 3. Skapa prompt med kontext baserat p√• valt l√§ge
    const systemPrompt = getSystemPromptForMode(mode, grade, context);
    console.log('[chatService] System prompt length:', systemPrompt.length);

    // 4. Bygg konversationshistorik - begr√§nsa till senaste 6 meddelanden f√∂r att spara tokens
    const recentMessages = previousMessages.slice(-6);
    const messages = [
      { role: 'system', content: systemPrompt },
      ...recentMessages.map(msg => ({
        role: msg.role,
        content: msg.content
      })),
      { role: 'user', content: userMessage }
    ];
    console.log('[chatService] Total messages:', messages.length, '(limited from', previousMessages.length, ')');

    // 5. Skicka till OpenAI/Azure OpenAI - √∂ka max_tokens f√∂r att ge utrymme f√∂r svar
    console.log('[chatService] Calling OpenAI API...');
    const completion = await client.chat.completions.create({
      model: getChatModel(),
      messages,
      ...getTemperatureOptions(0.7),
      ...getMaxTokenOptions(2000)
    });
    console.log('[chatService] Got completion:', completion.choices[0]);

    const responseMessage = completion.choices[0].message.content;
    console.log('[chatService] Response message:', responseMessage ? responseMessage.substring(0, 100) : 'EMPTY!');

    return {
      message: responseMessage,
      sources: relevantChunks.map(c => ({
        text: c.text.substring(0, 100) + '...',
        relevance: 'high'
      }))
    };
  } catch (error) {
    console.error('Chat-fel:', error);
    throw new Error(`Kunde inte generera svar: ${error.message}`);
  }
}
